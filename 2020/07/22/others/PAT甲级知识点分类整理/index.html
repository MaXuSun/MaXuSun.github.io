<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PAT甲级题目解析和知识点分类整理 | 莫等</title><meta name="description" content="今天整理电脑，发现了去年为了考研浙大计算机整理的PAT资料。现在考研已经尘埃落定。想到当时盲目刷题浪费了好多时间，在这里希望将整理的东西放到网上，方便后来者学习。 PAT的命题趋势将PAT甲级中的题目从第一题刷到最后一题，可以明显感受到，PAT甲级的题目风格发生了很明显的变化。从早期的模拟型题目变成了后来以数据结构和算法为主的固定题型。如果时间紧迫的话，可以只刷后一般的题目，放弃前一半的题目，因为"><meta name="keywords" content="PAT,算法"><meta name="author" content="MaXu"><meta name="copyright" content="MaXu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/07/22/others/PAT%E7%94%B2%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="PAT甲级题目解析和知识点分类整理"><meta property="og:url" content="http://yoursite.com/2020/07/22/others/PAT%E7%94%B2%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/"><meta property="og:site_name" content="莫等"><meta property="og:description" content="今天整理电脑，发现了去年为了考研浙大计算机整理的PAT资料。现在考研已经尘埃落定。想到当时盲目刷题浪费了好多时间，在这里希望将整理的东西放到网上，方便后来者学习。 PAT的命题趋势将PAT甲级中的题目从第一题刷到最后一题，可以明显感受到，PAT甲级的题目风格发生了很明显的变化。从早期的模拟型题目变成了后来以数据结构和算法为主的固定题型。如果时间紧迫的话，可以只刷后一般的题目，放弃前一半的题目，因为"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-07-22T13:11:05.000Z"><meta property="article:modified_time" content="2021-11-21T02:51:55.662Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="vue-element动态渲染placeholder的值" href="http://yoursite.com/2020/07/26/vue/vue-element%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93placeholder%E7%9A%84%E5%80%BC/"><link rel="next" title="BOM和DOM学习" href="http://yoursite.com/2020/07/16/others/BOM%E5%92%8CDOM%E5%AD%A6%E4%B9%A0/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?<script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?9828f48f6faa082e79d85e646485024c"; var s = document.getElementsByTagName("script")[0];  s.parentNode.insertBefore(hm, s); })();";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"0UFLIY697P","apiKey":"06ae37cf40bffb92771a913505f501c2","indexName":"XL","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: {"languages":{"author":"作者: MaXu","link":"链接: ","source":"来源: 莫等","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.4.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PAT%E7%9A%84%E5%91%BD%E9%A2%98%E8%B6%8B%E5%8A%BF"><span class="toc-number">1.</span> <span class="toc-text">PAT的命题趋势</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PAT%E9%A2%98%E7%9B%AE%E6%8C%89%E5%88%86%E6%95%B0%E5%92%8C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%86%E7%BA%A7"><span class="toc-number">2.</span> <span class="toc-text">PAT题目按分数和知识点分级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E5%88%86%E6%AE%B5"><span class="toc-number">2.1.</span> <span class="toc-text">20分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E5%88%86%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">25分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E5%88%86%E6%AE%B5"><span class="toc-number">2.3.</span> <span class="toc-text">30分段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">知识点整理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%89%88%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">详细版知识点整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DP-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.1.2.</span> <span class="toc-text">DP(动态规划)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">3.1.3.</span> <span class="toc-text">图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88-%E9%98%9F%E5%88%97-%E5%93%88%E5%B8%8C-%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.4.</span> <span class="toc-text">栈,队列,哈希,链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">3.1.5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%88%96%E8%80%85%E5%BB%BA%E6%A0%91"><span class="toc-number">3.1.5.4.</span> <span class="toc-text">完全二叉树(判断是否是完全二叉树或者建树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">3.1.5.5.</span> <span class="toc-text">哈夫曼树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.1.5.6.</span> <span class="toc-text">普通二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%B0%E5%BE%97%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.6.</span> <span class="toc-text">并查集:一定要记得初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.7.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.1.8.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-1"><span class="toc-number">4.</span> <span class="toc-text">其他</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">莫等</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">PAT甲级题目解析和知识点分类整理</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-22 21:11:05"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-22</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-11-21 10:51:55"><i class="fas fa-history fa-fw"></i> 更新于 2021-11-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>今天整理电脑，发现了去年为了考研浙大计算机整理的PAT资料。现在考研已经尘埃落定。想到当时盲目刷题浪费了好多时间，在这里希望将整理的东西放到网上，方便后来者学习。</p>
<h1 id="PAT的命题趋势"><a href="#PAT的命题趋势" class="headerlink" title="PAT的命题趋势"></a>PAT的命题趋势</h1><p>将PAT甲级中的题目从第一题刷到最后一题，可以明显感受到，PAT甲级的题目风格发生了很明显的变化。从早期的模拟型题目变成了后来以数据结构和算法为主的固定题型。如果时间紧迫的话，可以只刷后一般的题目，放弃前一半的题目，因为前一半题目的出题风格已经过时了。</p>
<h1 id="PAT题目按分数和知识点分级"><a href="#PAT题目按分数和知识点分级" class="headerlink" title="PAT题目按分数和知识点分级"></a>PAT题目按分数和知识点分级</h1><p>PAT按照分数分为20，25，30分。下面是将题目按照这3个分数段进行整理。<br>其中25分和30分的题目代码在这里：<a target="_blank" rel="noopener" href="https://github.com/MaXuSun/PAT/tree/master/pat%E9%A2%98%E7%9B%AE%E5%88%86%E7%BA%A7">代码</a></p>
<h2 id="20分段"><a href="#20分段" class="headerlink" title="20分段"></a>20分段</h2><p>20分的部分题目没有标注涉及的知识点，没有标注的这些题目说明非常简单，只是用来熟悉编程语言的，稍微有些基础的同学可以跳过，没有基础的同学可以先做这些题目。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>知识点</th>
<th>是否建议二刷</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1005</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1008</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1011</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1015</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1019</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1023</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1027</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1031</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1035</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1041</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1042</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1046</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1050</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1054</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1058</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1061</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1065</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1069</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1073</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1088</td>
<td>分数处理</td>
<td></td>
</tr>
<tr>
<td>1092</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1096</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1100</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1104</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1108</td>
<td>字符串于浮点数间的转换</td>
<td>二刷</td>
</tr>
<tr>
<td>1112</td>
<td>字符串处理</td>
<td>可二刷</td>
</tr>
<tr>
<td>1116</td>
<td>还行,hash</td>
<td></td>
</tr>
<tr>
<td>1120</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1124</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1128</td>
<td>n皇后问题，但是简化了，只是让验证而已</td>
<td></td>
</tr>
<tr>
<td>1132</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1136</td>
<td>字符串处理数字加减</td>
<td>可二刷</td>
</tr>
<tr>
<td>1140</td>
<td>字符串处理</td>
<td>二刷</td>
</tr>
<tr>
<td>1144</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1148</td>
<td>狼人杀</td>
<td></td>
</tr>
<tr>
<td>1152</td>
<td>字符串处理(自己想麻烦了)</td>
<td>二刷</td>
</tr>
</tbody></table>
<h2 id="25分段"><a href="#25分段" class="headerlink" title="25分段"></a>25分段</h2><p>25分的题目比20分的题目多了解决方法和备注。没有标注解决方法的题目是因为比较简单或者涉及的解决方法已经在其他题目中使用。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>知识点</th>
<th>解决方法</th>
<th>是否建议二刷</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1002</td>
<td>模拟多项式加</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1003</td>
<td>图</td>
<td>最短路径+点权+最短路径数量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1006</td>
<td>查找元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1007</td>
<td>DP</td>
<td>最大连续子序列</td>
<td>可二刷</td>
<td></td>
</tr>
<tr>
<td>1009</td>
<td>时间处理</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1010</td>
<td>二分法</td>
<td>基数数字转换</td>
<td></td>
<td>这里如果不使用二分法,只有一个测试点过不去</td>
</tr>
<tr>
<td>1012</td>
<td>排序</td>
<td>结构体排序</td>
<td></td>
<td>亮点在,对四门课同样的排序可以只写一个cmp,结构体中用数组即可</td>
</tr>
<tr>
<td>1013</td>
<td>图</td>
<td>无向图的连通分量</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1016</td>
<td>排序</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1017</td>
<td>模拟银行</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1020</td>
<td>二叉树查找树</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1021</td>
<td>图</td>
<td>无向图+连通分量+最深结点*2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1024</td>
<td>大整数</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1025</td>
<td>排序</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1028</td>
<td>排序</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1029</td>
<td>two pointers</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1032</td>
<td>链表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1033</td>
<td>贪心</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1036</td>
<td>查找元素</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1037</td>
<td>贪心</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1039</td>
<td>STL应用</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1040</td>
<td>DP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1043</td>
<td>二叉查找树</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1044</td>
<td>二分查找</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1047</td>
<td>STL应用</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1048</td>
<td>散列</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1051</td>
<td>栈</td>
<td>判断序列是否为出栈序列</td>
<td>二刷</td>
<td>这里可用这种最笨的方法来输出所有栈的结果</td>
</tr>
<tr>
<td>1052</td>
<td>链表</td>
<td>模拟静态链表,有点坑</td>
<td>二刷</td>
<td>里面有很多好的写法</td>
</tr>
<tr>
<td>1055</td>
<td>排序</td>
<td>结构体排序</td>
<td></td>
<td>有点水</td>
</tr>
<tr>
<td>1056</td>
<td>队列</td>
<td></td>
<td>可二刷</td>
<td>题目不是多难,就是开始想岔了,没读懂题目</td>
</tr>
<tr>
<td>1059</td>
<td>素数表建立</td>
<td>数的素数分解</td>
<td>二刷</td>
<td>这题变形可出关于正整数的因子个数</td>
</tr>
<tr>
<td>1060</td>
<td>科学计数法</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1062</td>
<td>排序</td>
<td>排序,cmp+sort</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1063</td>
<td>set,STL应用</td>
<td>set应用</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1066</td>
<td>avi</td>
<td>AVI的建立</td>
<td>可二刷</td>
<td>这次使用的是静态链表方法</td>
</tr>
<tr>
<td>1067</td>
<td>贪心</td>
<td>贪心+排序</td>
<td>二刷</td>
<td>挺绕的一题</td>
</tr>
<tr>
<td>1070</td>
<td>贪心</td>
<td>贪心</td>
<td></td>
<td>有一个测试用例没过,然后发现因为float的数据被我认为是int了</td>
</tr>
<tr>
<td>1071</td>
<td>map,STL</td>
<td>字符串处理</td>
<td></td>
<td>这里使用两个字符串统计单词，要比之前我只用索引来确定方便很多</td>
</tr>
<tr>
<td>1074</td>
<td>链表</td>
<td>静态链表反转</td>
<td>二刷</td>
<td>数据和地址分离，直接反转地址，太特么秀了</td>
</tr>
<tr>
<td>1078</td>
<td>hash</td>
<td>Hash二次探测法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1079</td>
<td>树</td>
<td>树+找叶结点+深度</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1082</td>
<td>字符串处理</td>
<td>数字的中国传统读法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1083</td>
<td>排序</td>
<td>排序</td>
<td></td>
<td>水题</td>
</tr>
<tr>
<td>1085</td>
<td>二分法</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1086</td>
<td>树</td>
<td>先序中序转后序</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1089</td>
<td>判断排序方法</td>
<td></td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1090</td>
<td>树</td>
<td>树+找叶结点+深度</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1093</td>
<td>逻辑题</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1094</td>
<td>树</td>
<td>树+最多结点层数</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1097</td>
<td>链表</td>
<td>链表分割</td>
<td>可二刷</td>
<td>仍然是用那种无赖的方法，很爽</td>
</tr>
<tr>
<td>1098</td>
<td>判断排序方法</td>
<td>堆排序+插入排序</td>
<td>与1089一起二刷</td>
<td></td>
</tr>
<tr>
<td>1101</td>
<td>快排</td>
<td>快排特点</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1102</td>
<td>树</td>
<td>树+层序+中序</td>
<td></td>
<td>indices:指数</td>
</tr>
<tr>
<td>1105</td>
<td>模拟</td>
<td>打印螺旋形矩阵</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1106</td>
<td>树</td>
<td>树+DFS+叶子最小的层</td>
<td>可以二刷</td>
<td></td>
</tr>
<tr>
<td>1109</td>
<td>逻辑题</td>
<td>拍照站位</td>
<td></td>
<td>不知道为啥错</td>
</tr>
<tr>
<td>1110</td>
<td>完全二叉树</td>
<td>判断一个树是不是完全二叉树</td>
<td>可二刷</td>
<td></td>
</tr>
<tr>
<td>1113</td>
<td>排序+贪心</td>
<td>贪心</td>
<td></td>
<td>有点水</td>
</tr>
<tr>
<td>1115</td>
<td>二叉查找树</td>
<td>二叉查找树+静态构建</td>
<td>二刷(必须)</td>
<td></td>
</tr>
<tr>
<td>1114</td>
<td>并查集</td>
<td>并查集统计很多</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1117</td>
<td>逻辑题</td>
<td>读懂题意就较为简单</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1118</td>
<td>并查集</td>
<td>并查集统计集合和元素个数</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1121</td>
<td>set应用</td>
<td>hash用法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1122</td>
<td>图</td>
<td>哈密顿环</td>
<td>二刷</td>
<td>可以再做,被自己写复杂了</td>
</tr>
<tr>
<td>1125</td>
<td>贪心</td>
<td>贪心,排序</td>
<td></td>
<td>题目不难，就是浮点数向整数舍入有点恶心</td>
</tr>
<tr>
<td>1126</td>
<td>图</td>
<td>欧拉图</td>
<td></td>
<td>这里需要判断图是否连通</td>
</tr>
<tr>
<td>1129</td>
<td>set应用，运算符重载</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1130</td>
<td>树</td>
<td>表达式树+中序</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1133</td>
<td>链表</td>
<td>模拟链表处理</td>
<td></td>
<td>链表处理不能忘了去不用的结点,并且有种非常无赖的方法</td>
</tr>
<tr>
<td>1134</td>
<td>hash</td>
<td>hash_set</td>
<td></td>
<td>这题如果使用set,则200多毫秒，如果使用hash_set则快些</td>
</tr>
<tr>
<td>1137</td>
<td>map映射,排序</td>
<td>float转int</td>
<td></td>
<td>四舍五入:round    向上取整:ceil    向下取整:floor,强转</td>
</tr>
<tr>
<td>1138</td>
<td>树</td>
<td>二叉树先序+中序转后序</td>
<td>可二刷</td>
<td>这里需要剪枝,另外这种代码可以不建树，直接由建树代码改造</td>
</tr>
<tr>
<td>1141</td>
<td>map,排序</td>
<td>map,STL的应用</td>
<td></td>
<td>这里有个坑：浮点转整形时，计算sum时，将sum全计算完再做，若每次都转再相加，精度严重丢失                            case insensitive:不区分大小写</td>
</tr>
<tr>
<td>1142</td>
<td>图</td>
<td>找完全图</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1145</td>
<td>哈希</td>
<td>Hash二次探测法+查找</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1146</td>
<td>图</td>
<td>topo排序</td>
<td>二刷</td>
<td>可以再做,被自己写复杂了</td>
</tr>
<tr>
<td>1149</td>
<td>STL应用</td>
<td>set应用</td>
<td></td>
<td>水题</td>
</tr>
<tr>
<td>1150</td>
<td>图</td>
<td>旅行商问题+哈密顿变体</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1153</td>
<td>排序,模拟</td>
<td>排序</td>
<td>二刷</td>
<td>答案的结构体设置特别好</td>
</tr>
<tr>
<td>1154</td>
<td>hash 图</td>
<td>图+边两端结点颜色不同</td>
<td></td>
<td>注意如何存储一个一个的边</td>
</tr>
</tbody></table>
<h2 id="30分段"><a href="#30分段" class="headerlink" title="30分段"></a>30分段</h2><p>30分的题目多了解决方法和备注。没有标注解决方法的题目是因为比较简单或者涉及的解决方法已经在其他题目中使用。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>知识点</th>
<th>解决方法</th>
<th>是否建议二刷</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1004</td>
<td>树遍历</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1014</td>
<td>队列</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1018</td>
<td>图</td>
<td>DFS+Dijkstra+三value</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1022</td>
<td>map映射,STL使用</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1026</td>
<td>模拟，排序</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1030</td>
<td>图</td>
<td>Dijkstra+二value</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1034</td>
<td>图</td>
<td>DFS+连通分量+分量所有边权和</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1038</td>
<td>贪心</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1045</td>
<td>DP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1049</td>
<td>数学</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1053</td>
<td>树遍历</td>
<td>DFS找路</td>
<td>可二刷</td>
<td></td>
</tr>
<tr>
<td>1057</td>
<td>树状数组</td>
<td>使用树状数组求序列中第k大数据</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1064</td>
<td>二叉查找树</td>
<td>在构建好的完全二叉树上先序遍历+层序遍历</td>
<td>可二刷(较水)</td>
<td></td>
</tr>
<tr>
<td>1068</td>
<td>01背包,DP</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1072</td>
<td>图</td>
<td>Dijkstra+三value</td>
<td>二刷</td>
<td>atoi需要stdlib包</td>
</tr>
<tr>
<td>1076</td>
<td>图</td>
<td>BFS+统计多少层以内结点数目</td>
<td>可二刷</td>
<td></td>
</tr>
<tr>
<td>1080</td>
<td>排序</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1087</td>
<td>图</td>
<td>Dijkstra+DFS+三value</td>
<td>可二刷</td>
<td>比较耗时间</td>
</tr>
<tr>
<td>1091</td>
<td>三维bfs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1095</td>
<td>map,排序</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1099</td>
<td>二叉查找树</td>
<td>静态二叉查找树构建</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1103</td>
<td>深度优先搜索DFS</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1107</td>
<td>并查集</td>
<td>使用并查集即可</td>
<td>可二刷</td>
<td></td>
</tr>
<tr>
<td>1111</td>
<td>图</td>
<td>Dijkstra+DFS+四value,两次Dijkstra</td>
<td>可二刷</td>
<td>这题理解错题意，浪费了时间</td>
</tr>
<tr>
<td>1119</td>
<td>二叉查找树</td>
<td>先序后序-&gt;中序</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1123</td>
<td>avi树</td>
<td>avi树构建+BFS+CBT</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1127</td>
<td>树</td>
<td>后序中序-&gt;层序)</td>
<td>可二刷</td>
<td>常规</td>
</tr>
<tr>
<td>1131</td>
<td>图</td>
<td></td>
<td></td>
<td>打印最短路径的格式太难了</td>
</tr>
<tr>
<td>1135</td>
<td>红黑树</td>
<td>判断一棵树是不是红黑树</td>
<td>二刷</td>
<td>里面有求树高和判断左右子树是否等高的代码</td>
</tr>
<tr>
<td>1139</td>
<td>图</td>
<td></td>
<td></td>
<td>题目时间改了,用DFS最后一个用例超时，可以直接暴力法，终点和起点同时遍历一个结点</td>
</tr>
<tr>
<td>1143</td>
<td>二叉查找树</td>
<td>LCA+数据排好序就是查找树的中序遍历</td>
<td>可二刷</td>
<td></td>
</tr>
<tr>
<td>1147</td>
<td>堆</td>
<td>判断堆是大根小根还是不是堆</td>
<td>可二刷</td>
<td></td>
</tr>
<tr>
<td>1151</td>
<td>树</td>
<td>LCA</td>
<td>二刷</td>
<td></td>
</tr>
<tr>
<td>1155</td>
<td>堆</td>
<td>判断是大根堆小根堆还是不是堆</td>
<td>二刷</td>
<td></td>
</tr>
</tbody></table>
<h1 id="知识点整理"><a href="#知识点整理" class="headerlink" title="知识点整理"></a>知识点整理</h1><p>知识点整理是考前临时抱佛脚看的，有两份，第一份较为详细，第二份较为精简。主要是一些样板代码和一些做题的注意点。<br>下面放的是详细版本的,PDF版本可以点击这里<a target="_blank" rel="noopener" href="https://github.com/MaXuSun/PAT/blob/master/pat%E6%95%B4%E5%90%88%E8%AF%A6%E7%BB%86%E7%89%88.pdf">详细版本pdf</a>。同时精简版本的PDF可以查看这里<a target="_blank" rel="noopener" href="https://github.com/MaXuSun/PAT/blob/master/pat%E6%95%B4%E5%90%88%E7%B2%BE%E7%AE%80%E7%89%88.pdf">精简版本pdf</a></p>
<h2 id="详细版知识点整理"><a href="#详细版知识点整理" class="headerlink" title="详细版知识点整理"></a>详细版知识点整理</h2><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; 求 c[<span class="number">1</span>,x]的 sum</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &gt;= <span class="number">1</span>;i -=lowbit(i))</span><br><span class="line">    sum+=c[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x;i &lt; MAXN;i+=lowbit(i))</span><br><span class="line">    c[i]+=v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DP-动态规划"><a href="#DP-动态规划" class="headerlink" title="DP(动态规划)"></a>DP(动态规划)</h3><ol>
<li>最大连续子序列:<code>dp[i] = max(A[i],dp[i]+A[i]);</code></li>
<li>最长不下降子序列:<code>dp[i] = max(1,dp[j]+1) (j=1,2,……,i-1, A[j]&lt;=A[i])</code></li>
<li>最长回文库： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    dp[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;A[i<span class="number">-1</span>]==A[i])&#123;</span><br><span class="line">    dp[i<span class="number">-1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> L = <span class="number">3</span>;L &lt;= len;L++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i + len - <span class="number">1</span> &lt; len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>]==<span class="number">1</span>&amp;&amp;A[i]==A[j])&#123;</span><br><span class="line">            dp[i][j]=<span class="number">1</span>;ans = L;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最长公共子序列： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = &#123;</span><br><span class="line">    dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>; A[i]=B[j];</span><br><span class="line">    max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>DAG</li>
<li>背包问题 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beibao</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = V;v &gt;= w[i];v--)&#123; 这是 <span class="number">01</span> 背包问题</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = w[i];v&lt;=V;v++)&#123; 这是完全背包问题</span><br><span class="line">            dp[v] = max(dp[v],dp[v-w[i]]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ol>
<li><p>最短路径</p>
<ul>
<li><p>Dijkstra</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(dis,dis+MAXN,inf);</span><br><span class="line">    fill(vis,vis+MAXN,<span class="literal">false</span>);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u =<span class="number">-1</span>,MIN = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;MIN)&#123;</span><br><span class="line">                u = j,MIN = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span>;vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v &lt; n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[[v]&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">                <span class="keyword">if</span>(G[u][v]+dis[u] &lt; dis[v])&#123;</span><br><span class="line">                    <span class="comment">//处理语句</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(G[u][v]+dis[u]==dis[v] &amp;&amp; 其他条件)&#123;</span><br><span class="line">                    <span class="comment">//处理语句</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> getPath(<span class="keyword">int</span> s)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==start)&#123;</span><br><span class="line">        tempPath.push_back(s);</span><br><span class="line">        <span class="number">1.</span>在这里计算对应的值</span><br><span class="line">        <span class="number">2.</span>计算完后进行相应的更新</span><br><span class="line">        <span class="number">3.</span>达到条件时 path = tempPath;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.push_back(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pre[s].size();i++)&#123;</span><br><span class="line">        getPath(pre[s][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>SPFA</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inq,<span class="literal">false</span>,<span class="keyword">sizeof</span>(inq)); inq 记录顶点是否在队列中</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num)); num 数组记录顶点的入队次数</span><br><span class="line">    fill(d,d+MAXN,INF);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>; u 不在队列中</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; Adj[u].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis &lt; d[v])&#123;</span><br><span class="line">                d[v] = d[u]+dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])&#123;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    inq[v] = <span class="literal">true</span>;</span><br><span class="line">                    num[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>最小生成树(Prim算法)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fill(d,d+MAXN,inf);</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,MIN = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)&#123;</span><br><span class="line">                u = j;MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        ans += d[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v= <span class="number">0</span>;v &lt; n;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">                <span class="keyword">if</span>(G[u][v] &lt; d[v])&#123;</span><br><span class="line">                    d[v] = G[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>树的遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).<span class="function">DFS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    这里是一些操作,包括剪枝之类的</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>;v &lt; n;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v]&amp;&amp;G[s][v]!=inf)&#123;</span><br><span class="line">            DFS(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTravel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])DFS(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>).<span class="function">BFS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);inq[s]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v&lt; n;v++)&#123;</span><br><span class="line">            <span class="comment">//计层，用结构体的话，放在这里</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;G[u][v]!=inf)&#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">                inq[v] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//计层的话,开数组放在这里，否则会被覆盖</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTravel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!inq[i])BFS(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>图论的题<br>这种题只能根据题目要求进行判断，另外判断成环，可以用 set 元素个数和读入结点个数是<br>否相等来判断</p>
</li>
<li><p>拓扑排序<br>较为简单，使用队列进行模拟就行，使用stl中的优先队列更方便。</p>
</li>
</ol>
<h3 id="栈-队列-哈希-链表"><a href="#栈-队列-哈希-链表" class="headerlink" title="栈,队列,哈希,链表"></a>栈,队列,哈希,链表</h3><ol>
<li>链表：数据与 next 分离，剔除无用结点，长度为 0 单独考虑</li>
<li>栈：如果考一个序列的所有出栈情况,最笨的方法是排列后分别判断;<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">判断一个序列是否是出栈顺序:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        s.push(i);</span><br><span class="line">        <span class="keyword">if</span>(q.front()==i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty()&amp;&amp;q.front()==s.top())&#123;</span><br><span class="line">            q.pop();s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>3.队列:容易题不常见,难的就是银行排队的题目,见机行事吧<br>4.hash(二次探测法)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; 二次探测法插入</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = (x+i*i)%size; 这里有的把 i*i 放在外面,根据题意判断</span><br><span class="line">        <span class="keyword">if</span>(hash[index]==<span class="number">-1</span>)&#123;</span><br><span class="line">            hash[index] = x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= size;i++)&#123; 与插入不同,这里带等号</span><br><span class="line">        <span class="keyword">int</span> index = (x+i*i)%size;</span><br><span class="line">        <span class="keyword">if</span>(hash[index]!=x &amp;&amp; hash[index]!=<span class="number">-1</span>)&#123;</span><br><span class="line">            cnt++:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>判断方法：根为黑色，所有红结点的儿子都是黑节点，所有结点左右子树的(黑节点)高度相<br>等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge1</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; 判断所有红节点的儿子都是黑节点</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(red[s])&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[s].l!=<span class="number">-1</span>&amp;&amp;red[T[s].l])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(T[s].r!=<span class="number">-1</span>&amp;&amp;red[T[s.r]])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge1(T[s].l)&amp;&amp;judge1(T[s].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; 判断所有结点左右子树的(黑结点)高度相等</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> L = getH(T[s].l);</span><br><span class="line">    <span class="keyword">int</span> R = getH(T[s].r);</span><br><span class="line">    <span class="keyword">if</span>(L!=R)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> judge2(T[s].l)&amp;&amp;judge2(T[s].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getH</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = getH(T[s].l);</span><br><span class="line">    <span class="keyword">int</span> R = getH(T[s].r);</span><br><span class="line">    <span class="keyword">return</span> max(L,R)+<span class="number">1</span>; 这是正常求树高</span><br><span class="line">    <span class="keyword">return</span> black[s]?max(L,R)+<span class="number">1</span>:max(L,R); 这是求(黑结点)高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>四种旋法：<br>    * 插在左子树的左子树:树右旋<br>    * 插在左子树的右子树:左子树左旋，然后树右旋<br>    * 插在右子树的右子树:树左旋<br>    * 插在右子树的左子树:右子树右旋，然后树左旋<br>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftRotate</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; 左旋</span><br><span class="line">    <span class="keyword">int</span> temp = T[s].r;</span><br><span class="line">    T[s].r = T[temp].l;</span><br><span class="line">    T[temp].l = s;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightRotate</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; 右旋</span><br><span class="line">    <span class="keyword">int</span> temp = T[s].l;</span><br><span class="line">    T[s].l = T[temp].r;</span><br><span class="line">    T[temp&#125;.r = s;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leftRightRoate</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; 左右旋</span><br><span class="line">    T[s].l = leftRotate(T[s].l);</span><br><span class="line">    <span class="keyword">return</span> rightRotate(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rightLeftRotate</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; 右左旋</span><br><span class="line">    T[s].r = rightRotate(T[s].r);</span><br><span class="line">    <span class="keyword">return</span> leftRotate(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertT</span><span class="params">(<span class="keyword">int</span>&amp; s,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">-1</span>) <span class="keyword">return</span> newnode(k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T[s].k)&#123;</span><br><span class="line">        T[s].l = insertT(T[s].l,k);</span><br><span class="line">        <span class="keyword">int</span> L = getH(T[s].l),R = getH(T[s].r);</span><br><span class="line">        <span class="keyword">if</span>(L - R &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &lt; T[T[s].l].k)&#123;</span><br><span class="line">                s = rightRotate(s);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s = leftRightRotate(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        T[s].r = insertT(T[s].r,k);</span><br><span class="line">        <span class="keyword">int</span> L = getH(T[s].l),R = getH(T[s].r);</span><br><span class="line">        <span class="keyword">if</span>(R-L &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; T[T[s].r].k)</span><br><span class="line">                s = leftRotate(s);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s = rightLeftRotate(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆首先必须是一个完全二叉树。</p>
<ol>
<li><p>判断是大根堆还是小根堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i/<span class="number">2</span>]&gt;T[i])small = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(T[i/<span class="number">2</span>]&lt;T[i])big = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!small&amp;&amp;!big)不是堆</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(small) 小根堆</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(big) 大根堆</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆排序：堆排序的特点是后面有 k 个数是排好序的且,这 k 个数都 &gt;= 第一个数每次从后向前找到第一个 &gt;= T[1]的数 T[p]，交换 T[p]和 T[1]后执行下面的调整算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low,j = <span class="number">2</span>*i;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high &amp;&amp; T[j+<span class="number">1</span>]&gt;T[j])j+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(T[i]&gt;=T[j])<span class="keyword">break</span>;</span><br><span class="line">        swap(T[i],T[j]);</span><br><span class="line">        i = j,j = <span class="number">2</span>*i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="完全二叉树-判断是否是完全二叉树或者建树"><a href="#完全二叉树-判断是否是完全二叉树或者建树" class="headerlink" title="完全二叉树(判断是否是完全二叉树或者建树)"></a>完全二叉树(判断是否是完全二叉树或者建树)</h4><ol>
<li>建树：直接用数组模拟</li>
<li>判断<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; 用 bfs 判断否是完全二叉树,如果遇到了非内结点后又遇到内结点则不是</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> isCom = <span class="literal">true</span>;;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">if</span>(T[u].l!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) isCom = <span class="literal">false</span>;</span><br><span class="line">            q.push(T[u].l);</span><br><span class="line">        &#125;<span class="keyword">else</span> flag = <span class="number">1</span>; 遇到叶子结点</span><br><span class="line">        <span class="keyword">if</span>(T[u].r!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) isCom = <span class="literal">false</span>;</span><br><span class="line">            q.push(T[u].r)；</span><br><span class="line">        &#125;<span class="keyword">else</span> flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123; 直接检测</span><br><span class="line">    <span class="keyword">int</span> half = len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>;i &lt; half;i++)&#123; 所有内结点</span><br><span class="line">        <span class="keyword">if</span>(T[i].l==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(T[i].r==<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = half+<span class="number">1</span>;i &lt;= n;i++)&#123; 所有叶子结点</span><br><span class="line">        <span class="keyword">if</span>(T[i].l!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(T[i].r!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[half].l==<span class="number">-1</span>&amp;&amp;T[half].r!=<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4></li>
<li>如果不用建树,就用优先队列:priority_queue</li>
<li>如果需要建树,是从下向上建,就要在结点中添加一个指向父节点的值</li>
</ol>
<h4 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h4><ol>
<li>构建<br> 先序+中序：<br> 后序+中序：<br> 先序+后序：如果有只有一个儿子的结点，则会有歧义<br> 中序+层序：这个暂时还未考</li>
<li>LCA(与上面构建类似)<br>五种情况：<br> u 是根<br> v 是根<br> u,v 在根的左侧<br> u,v 在根的右侧<br> u,v 在根的两侧</li>
<li>遍历,先序遍历,后序遍历,中序遍历<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; T[u].size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = T[u][i];</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; T[s].size();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = T[s][i];</span><br><span class="line">        DFS(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="并查集-一定要记得初始化"><a href="#并查集-一定要记得初始化" class="headerlink" title="并查集:一定要记得初始化"></a>并查集:一定要记得初始化</h3><p>对于并查集的题目，在统计时要使用 findFa(x)来查找 father，因为 father[x]里面存的可能不<br>是祖先而是直系父亲</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> Fa = findFa(father[x]);</span><br><span class="line">        father[x] = Fa;</span><br><span class="line">        <span class="keyword">return</span> Fa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Fx = findFa(x);</span><br><span class="line">    <span class="keyword">int</span> Fy = findFa(y);</span><br><span class="line">    father[Fx] = Fy;</span><br><span class="line">    <span class="keyword">return</span> Fy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol>
<li><p>快速排序：特点：每次排完,排好的元素在最终结果对应的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[low];<span class="comment">//基准数据</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="comment">//当队尾元素大于等于基准元素,向前挪动 high 指针</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= temp)</span><br><span class="line">            high--;</span><br><span class="line">        arr[low] = arr[high];</span><br><span class="line">        <span class="comment">//当队首指针小于等于基准元素,向后挪动 low 指针</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= temp)</span><br><span class="line">            low++;</span><br><span class="line">        arr[high] = arr[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 temp 放在该在的位置</span></span><br><span class="line">    arr[low] = temp;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>堆排序：前面说了</p>
</li>
<li><p>插入排序：开始 k 个元素排好,后面的与输入序列一样</p>
</li>
</ol>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>数字转<code>string</code><br> <code>sprintf(chs,&quot;%d&quot;,sum,&#39;,&#39;);</code>//先将数字存在 char 数组中<br> <code>string str = chs;</code> //将 char 数组转为 string</li>
<li>对时间进行排序,可以使用 std 的字符串直接对字符串的时间进行比较。</li>
<li>对于中序，后序先序等互相获得的题目,递归条件可以改成通用<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preL&gt;preR)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(preL == preR)&#123;</span><br><span class="line">    post.push_back(pre[preL]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对于<code>AVL</code>树,注意：左旋右旋一定要写对，如果结果不对很可能是因为左旋右旋插入函数中,插入结点后对树进行调整时 要记得将旋后的返回值赋值给<code>s</code>,如: <code>s = rightRotate(s)</code></li>
<li>除了只涉及完全二叉树和图，一定要建结点，不要浪费时间，有时候用到子树<code>T[T[s].l]</code>,一定要先检查是否为-1</li>
<li>对于数<code>1-n</code>中有多少个<code>num(1&lt;= num &lt;=9 )</code>的题目，对第<code>i</code>位进行分离即可,即 <code>ai = num,ai&lt;num,ai&gt;num;</code>分别得出左右数的大小，然后乘在一起等操作即可。</li>
<li>有些数据可能是<code>float</code>,结果当<code>int</code>处理</li>
<li>取整:四舍五入:<code>round</code>向上取整:<code>ceil</code>向下取整:<code>floor</code>,强转</li>
<li>浮点转整形时，计算 sum 时，将 sum 全计算完再做，若每次都转再相加，精度严重丢<br>失</li>
<li><code>hash_set</code>用法：加上下面两句<code>#include &lt;hash_set&gt; using namespace __gnu_cxx</code>;<br>(11). <code>string.rbegin()</code>,<code>rend()</code>是从右向左遍历<br>(12). <code>atoi(str.c_str())</code>需要用到<code>stdlib.h</code>库, <code>cctype</code>库里有一些用到的函数<br>(13). <code>cin &gt;&gt; int</code>;后面跟<code>getline</code>，<code>getline</code>会得到一个<code>\n</code></li>
</ol>
<h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p>在这里说一些自己当时犯的错，供后来人吸取教训：</p>
<ol>
<li><strong>平时做题练习的时候一定不要在意题目的对错，刚开始刷题的时候因为在意对错和得分，甚至去网上抄袭别人的代码，一知半解的。然后就得到了报应。第一次考试的时候才考79。不得已二刷，然后耽误了考研的复习。</strong></li>
<li><strong>晴神的书中涉及的知识点太多太杂，很多是以前命题的知识点，一定要把后一半的题目做完，PAT的命题风格变化还是很明显的。有些知识点已经很久没有出了，或者出在20分的题中。把精力多放在与数据结构知识点结合的方面。</strong></li>
<li>对于知识点方面，可以看看这篇博客，总结的很详细。<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3814d99bed25">宇宙无敌PAT考纲</a>。这个博客的PDF版本我整理下来了，可以在这里查看:<a target="_blank" rel="noopener" href="https://github.com/MaXuSun/PAT/blob/master/%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8CPAT-A%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%80%83%E7%BA%B2%20-%20%E7%AE%80%E4%B9%A6.pdf">考纲PDF版本</a>。代码方面，建议看<a target="_blank" rel="noopener" href="https://www.liuchuo.net/archives/tag/pat">柳神的博客</a>，所有题目的PDF版本建议去柳神博客上购买订阅，几块钱不贵。</li>
<li><strong>祝看到这篇博客的同学PAT满分，考研顺利进浙大。</strong></li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">MaXu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/22/others/PAT%E7%94%B2%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/">http://yoursite.com/2020/07/22/others/PAT%E7%94%B2%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">莫等</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PAT/">PAT</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信" onclick="window.open('/img/wechat.png')"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝" onclick="window.open('/img/alipay.png')"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/26/vue/vue-element%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93placeholder%E7%9A%84%E5%80%BC/"><img class="prev-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vue-element动态渲染placeholder的值</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/16/others/BOM%E5%92%8CDOM%E5%AD%A6%E4%B9%A0/"><img class="next-cover" data-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BOM和DOM学习</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '87a0ded36beef5920202',
  clientSecret: '9a135a56fa831bebe6b64481964dadfefe5a1b19',
  repo: 'MaXuSun.github.io',
  owner: 'MaXuSun',
  admin: ['MaXuSun'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CH',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2022 By MaXu</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi,welcome to my <a target="_blank" rel="noopener" href="https://maxusun.github.io/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">簡</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/algolia.js"></script></body></html>